#!/bin/bash
# =============================================================================
# qubinode-dns - Unified DNS Management CLI
# ADR-0055: Zero-Friction Infrastructure Services
# =============================================================================
#
# Supported DNS providers:
# - FreeIPA (default for Qubinode)
# - nsupdate (RFC 2136 dynamic DNS)
#
# Usage:
#   qubinode-dns add <hostname> <ip> [--ptr] [--ttl <seconds>]
#   qubinode-dns remove <hostname>
#   qubinode-dns add-cname <alias> <target>
#   qubinode-dns add-srv <service> <target> <port> [--priority <n>] [--weight <n>]
#   qubinode-dns list [zone]
#   qubinode-dns sync-inventory
#   qubinode-dns check <hostname>
#
set -euo pipefail

# =============================================================================
# Configuration
# =============================================================================

CONFIG_FILE="${QUBINODE_DNS_CONFIG:-/etc/qubinode/infra.conf}"
DNS_PROVIDER="${QUBINODE_DNS_PROVIDER:-auto}"
DOMAIN="${QUBINODE_DOMAIN:-example.com}"
DEFAULT_TTL="${QUBINODE_DNS_TTL:-3600}"

# FreeIPA settings
FREEIPA_SERVER="${FREEIPA_SERVER:-}"
FREEIPA_REALM="${FREEIPA_REALM:-}"
FREEIPA_ADMIN="${FREEIPA_ADMIN:-admin}"

# Verbose mode
VERBOSE="${VERBOSE:-false}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# =============================================================================
# Helper Functions
# =============================================================================

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

log_debug() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo -e "${BLUE}[DEBUG]${NC} $1"
    fi
}

# Load configuration file
load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        log_debug "Loading config from $CONFIG_FILE"
        # Parse INI-style config
        while IFS='=' read -r key value; do
            key=$(echo "$key" | tr -d ' ')
            value=$(echo "$value" | tr -d ' ')
            case "$key" in
                domain) DOMAIN="$value" ;;
                provider) DNS_PROVIDER="$value" ;;
                freeipa_server) FREEIPA_SERVER="$value" ;;
                freeipa_realm) FREEIPA_REALM="$value" ;;
            esac
        done < <(grep -v '^#' "$CONFIG_FILE" | grep -v '^\[' | grep '=')
    fi
}

# Auto-detect DNS provider
detect_provider() {
    if [[ "$DNS_PROVIDER" != "auto" ]]; then
        return
    fi

    # Check for FreeIPA
    if command -v ipa &>/dev/null; then
        # Check for valid Kerberos ticket
        if klist -s 2>/dev/null; then
            DNS_PROVIDER="freeipa"
            log_debug "Detected FreeIPA with valid Kerberos ticket"
            return
        fi
    fi

    # Check for FreeIPA server via DNS
    if [[ -z "$FREEIPA_SERVER" ]]; then
        FREEIPA_SERVER=$(dig +short _ldap._tcp.${DOMAIN} SRV 2>/dev/null | awk '{print $4}' | sed 's/\.$//' | head -1)
    fi

    if [[ -n "$FREEIPA_SERVER" ]]; then
        DNS_PROVIDER="freeipa"
        log_debug "Detected FreeIPA server: $FREEIPA_SERVER"
        return
    fi

    # Check for nsupdate
    if command -v nsupdate &>/dev/null; then
        DNS_PROVIDER="nsupdate"
        log_debug "Using nsupdate for dynamic DNS"
        return
    fi

    log_error "No DNS provider detected. Install ipa-client or nsupdate."
    exit 1
}

# Extract zone and record name from FQDN
parse_hostname() {
    local fqdn="$1"

    # If hostname doesn't contain domain, append it
    if [[ "$fqdn" != *"."* ]]; then
        fqdn="${fqdn}.${DOMAIN}"
    fi

    # Extract zone (everything after first dot)
    RECORD_ZONE="${fqdn#*.}"
    # Extract record name (everything before first dot)
    RECORD_NAME="${fqdn%%.*}"
    # Full FQDN
    RECORD_FQDN="$fqdn"
}

# Get reverse DNS zone and record
get_reverse_zone() {
    local ip="$1"
    IFS='.' read -r -a octets <<< "$ip"

    # Class C reverse zone (most common)
    REVERSE_ZONE="${octets[2]}.${octets[1]}.${octets[0]}.in-addr.arpa"
    REVERSE_RECORD="${octets[3]}"
}

# Ensure FreeIPA authentication
ensure_freeipa_auth() {
    if ! klist -s 2>/dev/null; then
        log_warn "No valid Kerberos ticket. Attempting kinit..."
        if [[ -n "${FREEIPA_PASSWORD:-}" ]]; then
            echo "$FREEIPA_PASSWORD" | kinit "$FREEIPA_ADMIN" 2>/dev/null
        else
            kinit "$FREEIPA_ADMIN"
        fi
    fi

    if ! klist -s 2>/dev/null; then
        log_error "Failed to obtain Kerberos ticket"
        exit 1
    fi
}

# =============================================================================
# FreeIPA DNS Operations
# =============================================================================

freeipa_add_a_record() {
    local hostname="$1"
    local ip="$2"
    local ttl="${3:-$DEFAULT_TTL}"

    parse_hostname "$hostname"
    ensure_freeipa_auth

    log_info "Adding A record: $RECORD_NAME.$RECORD_ZONE -> $ip"

    # Check if zone exists
    if ! ipa dnszone-show "$RECORD_ZONE" &>/dev/null; then
        log_warn "Zone $RECORD_ZONE does not exist. Creating..."
        ipa dnszone-add "$RECORD_ZONE" --skip-overlap-check || {
            log_error "Failed to create zone $RECORD_ZONE"
            return 1
        }
    fi

    # Add or modify A record
    if ipa dnsrecord-show "$RECORD_ZONE" "$RECORD_NAME" &>/dev/null; then
        log_debug "Record exists, modifying..."
        ipa dnsrecord-mod "$RECORD_ZONE" "$RECORD_NAME" \
            --a-rec="$ip" \
            --a-rec-ttl="$ttl" 2>/dev/null || \
        ipa dnsrecord-add "$RECORD_ZONE" "$RECORD_NAME" \
            --a-rec="$ip" \
            --a-rec-ttl="$ttl"
    else
        ipa dnsrecord-add "$RECORD_ZONE" "$RECORD_NAME" \
            --a-rec="$ip" \
            --a-rec-ttl="$ttl"
    fi

    log_info "A record created: ${RECORD_NAME}.${RECORD_ZONE} -> $ip"
}

freeipa_add_ptr_record() {
    local ip="$1"
    local hostname="$2"

    parse_hostname "$hostname"
    get_reverse_zone "$ip"
    ensure_freeipa_auth

    log_info "Adding PTR record: $ip -> ${RECORD_FQDN}."

    # Check if reverse zone exists
    if ! ipa dnszone-show "$REVERSE_ZONE" &>/dev/null; then
        log_warn "Reverse zone $REVERSE_ZONE does not exist. Creating..."
        ipa dnszone-add "$REVERSE_ZONE" --skip-overlap-check || {
            log_warn "Could not create reverse zone (may require manual setup)"
            return 0
        }
    fi

    # Add PTR record
    ipa dnsrecord-add "$REVERSE_ZONE" "$REVERSE_RECORD" \
        --ptr-rec="${RECORD_FQDN}." 2>/dev/null || {
        log_debug "PTR record may already exist or zone not writable"
    }

    log_info "PTR record created: $ip -> ${RECORD_FQDN}."
}

freeipa_add_cname_record() {
    local alias="$1"
    local target="$2"

    parse_hostname "$alias"
    local alias_zone="$RECORD_ZONE"
    local alias_name="$RECORD_NAME"

    parse_hostname "$target"
    ensure_freeipa_auth

    log_info "Adding CNAME record: $alias_name.$alias_zone -> ${RECORD_FQDN}."

    ipa dnsrecord-add "$alias_zone" "$alias_name" \
        --cname-rec="${RECORD_FQDN}."

    log_info "CNAME record created: ${alias_name}.${alias_zone} -> ${RECORD_FQDN}."
}

freeipa_add_srv_record() {
    local service="$1"
    local target="$2"
    local port="$3"
    local priority="${4:-10}"
    local weight="${5:-100}"

    # SRV record format: _service._proto.domain
    local srv_zone="${service#*._*.}"
    local srv_name="${service%.$srv_zone}"

    parse_hostname "$target"
    ensure_freeipa_auth

    log_info "Adding SRV record: $service -> ${RECORD_FQDN}:$port"

    ipa dnsrecord-add "$srv_zone" "$srv_name" \
        --srv-rec="$priority $weight $port ${RECORD_FQDN}."

    log_info "SRV record created"
}

freeipa_remove_record() {
    local hostname="$1"

    parse_hostname "$hostname"
    ensure_freeipa_auth

    log_info "Removing DNS record: ${RECORD_NAME}.${RECORD_ZONE}"

    # Get current record to find IP for PTR cleanup
    local ip
    ip=$(ipa dnsrecord-show "$RECORD_ZONE" "$RECORD_NAME" 2>/dev/null | \
         grep "A record:" | awk '{print $3}')

    # Remove A record
    ipa dnsrecord-del "$RECORD_ZONE" "$RECORD_NAME" --del-all 2>/dev/null || {
        log_warn "Record may not exist: ${RECORD_NAME}.${RECORD_ZONE}"
    }

    # Remove PTR record if IP was found
    if [[ -n "$ip" ]]; then
        get_reverse_zone "$ip"
        ipa dnsrecord-del "$REVERSE_ZONE" "$REVERSE_RECORD" --del-all 2>/dev/null || true
        log_debug "Removed PTR record for $ip"
    fi

    log_info "DNS record removed: ${RECORD_NAME}.${RECORD_ZONE}"
}

freeipa_list_records() {
    local zone="${1:-$DOMAIN}"

    ensure_freeipa_auth

    log_info "Listing DNS records for zone: $zone"
    echo ""

    ipa dnsrecord-find "$zone" 2>/dev/null || {
        log_error "Could not list records for zone: $zone"
        return 1
    }
}

freeipa_check_record() {
    local hostname="$1"

    parse_hostname "$hostname"

    echo "DNS lookup for: $RECORD_FQDN"
    echo "========================================"

    # Forward lookup
    echo "Forward (A) record:"
    dig +short "$RECORD_FQDN" A || echo "  Not found"

    # Get IP for reverse lookup
    local ip
    ip=$(dig +short "$RECORD_FQDN" A 2>/dev/null | head -1)

    if [[ -n "$ip" ]]; then
        echo ""
        echo "Reverse (PTR) record for $ip:"
        dig +short -x "$ip" || echo "  Not found"
    fi

    # Check in FreeIPA directly
    if [[ "$DNS_PROVIDER" == "freeipa" ]]; then
        ensure_freeipa_auth
        echo ""
        echo "FreeIPA record details:"
        ipa dnsrecord-show "$RECORD_ZONE" "$RECORD_NAME" 2>/dev/null || echo "  Not found in FreeIPA"
    fi
}

# =============================================================================
# nsupdate DNS Operations
# =============================================================================

nsupdate_add_record() {
    local hostname="$1"
    local ip="$2"
    local ttl="${3:-$DEFAULT_TTL}"
    local create_ptr="${4:-false}"

    parse_hostname "$hostname"

    log_info "Adding A record via nsupdate: $RECORD_FQDN -> $ip"

    # Create nsupdate commands
    local commands="server ${DNS_SERVER:-127.0.0.1}
update delete ${RECORD_FQDN}. A
update add ${RECORD_FQDN}. $ttl A $ip
send"

    echo "$commands" | nsupdate -k "${NSUPDATE_KEY:-}" || {
        log_error "nsupdate failed"
        return 1
    }

    if [[ "$create_ptr" == "true" ]]; then
        get_reverse_zone "$ip"
        local ptr_commands="server ${DNS_SERVER:-127.0.0.1}
update delete ${REVERSE_RECORD}.${REVERSE_ZONE}. PTR
update add ${REVERSE_RECORD}.${REVERSE_ZONE}. $ttl PTR ${RECORD_FQDN}.
send"
        echo "$ptr_commands" | nsupdate -k "${NSUPDATE_KEY:-}" || true
    fi

    log_info "DNS record added via nsupdate"
}

nsupdate_remove_record() {
    local hostname="$1"

    parse_hostname "$hostname"

    log_info "Removing DNS record via nsupdate: $RECORD_FQDN"

    # Get IP for PTR cleanup
    local ip
    ip=$(dig +short "$RECORD_FQDN" A 2>/dev/null | head -1)

    local commands="server ${DNS_SERVER:-127.0.0.1}
update delete ${RECORD_FQDN}. A
send"

    echo "$commands" | nsupdate -k "${NSUPDATE_KEY:-}" || true

    if [[ -n "$ip" ]]; then
        get_reverse_zone "$ip"
        local ptr_commands="server ${DNS_SERVER:-127.0.0.1}
update delete ${REVERSE_RECORD}.${REVERSE_ZONE}. PTR
send"
        echo "$ptr_commands" | nsupdate -k "${NSUPDATE_KEY:-}" || true
    fi

    log_info "DNS record removed via nsupdate"
}

# =============================================================================
# Sync Operations
# =============================================================================

sync_inventory() {
    local inventory_file="${1:-/etc/qubinode/certs/inventory.json}"

    if [[ ! -f "$inventory_file" ]]; then
        log_error "Inventory file not found: $inventory_file"
        return 1
    fi

    log_info "Syncing DNS from inventory: $inventory_file"

    # Parse JSON inventory and create DNS records
    jq -r '.certificates[] | "\(.hostname) \(.ip // "")"' "$inventory_file" 2>/dev/null | \
    while read -r hostname ip; do
        if [[ -n "$hostname" && -n "$ip" ]]; then
            dns_add "$hostname" "$ip" || true
        fi
    done

    log_info "Inventory sync complete"
}

# =============================================================================
# Main Command Dispatch
# =============================================================================

dns_add() {
    local hostname="$1"
    local ip="$2"
    local create_ptr="false"
    local ttl="$DEFAULT_TTL"

    shift 2
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --ptr) create_ptr="true"; shift ;;
            --ttl) ttl="$2"; shift 2 ;;
            *) shift ;;
        esac
    done

    case "$DNS_PROVIDER" in
        freeipa)
            freeipa_add_a_record "$hostname" "$ip" "$ttl"
            if [[ "$create_ptr" == "true" ]]; then
                freeipa_add_ptr_record "$ip" "$hostname"
            fi
            ;;
        nsupdate)
            nsupdate_add_record "$hostname" "$ip" "$ttl" "$create_ptr"
            ;;
        *)
            log_error "Unknown DNS provider: $DNS_PROVIDER"
            exit 1
            ;;
    esac
}

dns_remove() {
    local hostname="$1"

    case "$DNS_PROVIDER" in
        freeipa)
            freeipa_remove_record "$hostname"
            ;;
        nsupdate)
            nsupdate_remove_record "$hostname"
            ;;
        *)
            log_error "Unknown DNS provider: $DNS_PROVIDER"
            exit 1
            ;;
    esac
}

usage() {
    cat << EOF
qubinode-dns - Unified DNS Management CLI
ADR-0055: Zero-Friction Infrastructure Services

USAGE:
    qubinode-dns <command> [options]

COMMANDS:
    add <hostname> <ip> [--ptr] [--ttl <seconds>]
        Add A record (and optionally PTR record)

    remove <hostname>
        Remove DNS record(s)

    add-cname <alias> <target>
        Add CNAME record

    add-srv <service> <target> <port> [--priority <n>] [--weight <n>]
        Add SRV record (e.g., _ldap._tcp.example.com)

    list [zone]
        List DNS records for zone

    check <hostname>
        Check DNS resolution for hostname

    sync-inventory
        Sync DNS from certificate inventory

    help
        Show this help message

OPTIONS:
    --ptr           Create reverse PTR record
    --ttl <seconds> Set TTL (default: 3600)
    --provider <p>  DNS provider: freeipa, nsupdate, auto
    --domain <d>    Domain name
    -v, --verbose   Verbose output

ENVIRONMENT:
    QUBINODE_DOMAIN       Default domain
    QUBINODE_DNS_PROVIDER DNS provider (auto, freeipa, nsupdate)
    FREEIPA_SERVER        FreeIPA server hostname
    FREEIPA_PASSWORD      FreeIPA admin password (optional)
    DNS_SERVER            DNS server for nsupdate
    NSUPDATE_KEY          TSIG key file for nsupdate

EXAMPLES:
    # Add A record
    qubinode-dns add myservice.example.com 192.168.122.100

    # Add A record with PTR
    qubinode-dns add myservice.example.com 192.168.122.100 --ptr

    # Add CNAME
    qubinode-dns add-cname www.example.com webserver.example.com

    # Remove record
    qubinode-dns remove myservice.example.com

    # List zone records
    qubinode-dns list example.com

    # Check hostname
    qubinode-dns check myservice.example.com

EOF
}

# =============================================================================
# Main
# =============================================================================

main() {
    # Parse global options first
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -v|--verbose) VERBOSE="true"; shift ;;
            --provider) DNS_PROVIDER="$2"; shift 2 ;;
            --domain) DOMAIN="$2"; shift 2 ;;
            *) break ;;
        esac
    done

    if [[ $# -lt 1 ]]; then
        usage
        exit 1
    fi

    # Load configuration
    load_config

    # Detect provider
    detect_provider

    log_debug "DNS Provider: $DNS_PROVIDER"
    log_debug "Domain: $DOMAIN"

    local command="$1"
    shift

    case "$command" in
        add)
            if [[ $# -lt 2 ]]; then
                log_error "Usage: qubinode-dns add <hostname> <ip> [--ptr] [--ttl <seconds>]"
                exit 1
            fi
            dns_add "$@"
            ;;
        remove|delete|rm)
            if [[ $# -lt 1 ]]; then
                log_error "Usage: qubinode-dns remove <hostname>"
                exit 1
            fi
            dns_remove "$1"
            ;;
        add-cname|cname)
            if [[ $# -lt 2 ]]; then
                log_error "Usage: qubinode-dns add-cname <alias> <target>"
                exit 1
            fi
            if [[ "$DNS_PROVIDER" == "freeipa" ]]; then
                freeipa_add_cname_record "$1" "$2"
            else
                log_error "CNAME not supported for provider: $DNS_PROVIDER"
                exit 1
            fi
            ;;
        add-srv|srv)
            if [[ $# -lt 3 ]]; then
                log_error "Usage: qubinode-dns add-srv <service> <target> <port>"
                exit 1
            fi
            if [[ "$DNS_PROVIDER" == "freeipa" ]]; then
                freeipa_add_srv_record "$1" "$2" "$3" "${4:-10}" "${5:-100}"
            else
                log_error "SRV not supported for provider: $DNS_PROVIDER"
                exit 1
            fi
            ;;
        list|ls)
            if [[ "$DNS_PROVIDER" == "freeipa" ]]; then
                freeipa_list_records "${1:-$DOMAIN}"
            else
                log_error "List not supported for provider: $DNS_PROVIDER"
                exit 1
            fi
            ;;
        check|lookup)
            if [[ $# -lt 1 ]]; then
                log_error "Usage: qubinode-dns check <hostname>"
                exit 1
            fi
            freeipa_check_record "$1"
            ;;
        sync-inventory|sync)
            sync_inventory "${1:-/etc/qubinode/certs/inventory.json}"
            ;;
        help|--help|-h)
            usage
            ;;
        *)
            log_error "Unknown command: $command"
            usage
            exit 1
            ;;
    esac
}

main "$@"
