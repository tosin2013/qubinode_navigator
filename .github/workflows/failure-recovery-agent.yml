# Failure Recovery Agent Workflow
# Per ADR-0069: Agentic Failure Diagnosis and Recovery
#
# This workflow is triggered when E2E test fails and provides:
# 1. Automatic root cause diagnosis using FailureAnalyzer
# 2. Recovery plan generation with multiple options
# 3. Automatic recovery execution (if confidence high enough)
# 4. GitHub issue escalation with full diagnostic context

name: Failure Recovery Agent

on:
  workflow_dispatch:
    inputs:
      failed_job:
        description: 'Name of the failed job to diagnose'
        required: true
        type: string
      failure_message:
        description: 'Error message from the failure'
        required: true
        type: string
      enable_auto_recovery:
        description: 'Enable automatic recovery execution'
        required: false
        type: boolean
        default: false

  # Can also be called from another workflow
  workflow_call:
    inputs:
      failed_job:
        description: 'Name of the failed job'
        required: true
        type: string
      failure_message:
        description: 'Error message'
        required: true
        type: string
      enable_auto_recovery:
        description: 'Enable automatic recovery'
        required: false
        type: boolean
        default: false

env:
  QUBINODE_HOME: /root/qubinode_navigator

jobs:
  diagnose-failure:
    name: Diagnose Failure
    runs-on: self-hosted
    outputs:
      root_cause: ${{ steps.diagnosis.outputs.root_cause }}
      confidence: ${{ steps.diagnosis.outputs.confidence }}
      recovery_option: ${{ steps.diagnosis.outputs.recovery_option }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt
          pip install -e .

      - name: Diagnose failure using FailureAnalyzer
        id: diagnosis
        run: |
          python3 << 'EOF'
          import json
          import sys
          import os
          from datetime import datetime

          # Add qubinode to path
          sys.path.insert(0, os.getcwd())

          from core.failure_analyzer import FailureAnalyzer, DiagnosticContext
          from core.recovery_planner import RecoveryPlanner

          # Initialize analyzer
          analyzer = FailureAnalyzer()

          # Create diagnostic context from inputs
          ctx = DiagnosticContext(
              plugin_name="${{ inputs.failed_job }}",
              failure_timestamp=datetime.now(),
              error_message="${{ inputs.failure_message }}",
          )

          # Collect system diagnostics
          print("[INFO] Collecting system diagnostics...")
          ctx.service_health = {
              "libvirtd": DiagnosticContext.get_service_status("libvirtd"),
              "podman": DiagnosticContext.get_service_status("podman"),
              "airflow": DiagnosticContext.get_service_status("airflow"),
          }
          ctx.system_resources = DiagnosticContext.get_system_resources()
          ctx.recent_logs = DiagnosticContext.get_plugin_logs("${{ inputs.failed_job }}")

          # Analyze failure
          print("[INFO] Analyzing failure...")
          analysis = analyzer.analyze(ctx)

          # Create recovery plan
          planner = RecoveryPlanner(
              github_token=os.getenv("GITHUB_TOKEN"),
              github_repo=os.getenv("GITHUB_REPOSITORY"),
          )
          plan = planner.plan_recovery(analysis)

          # Output diagnostics as JSON
          result = {
              "root_cause": analysis.root_cause.value,
              "confidence": analysis.confidence,
              "severity": analysis.severity.value,
              "description": analysis.root_cause_description,
              "affected_services": analysis.affected_services,
              "recommended_action": plan.recommended_option.action_type.value if plan.recommended_option else "escalate",
              "recovery_options": [
                  {
                      "type": opt.action_type.value,
                      "confidence": opt.confidence,
                      "risk": opt.risk_level,
                      "duration_seconds": opt.estimated_duration_seconds,
                  }
                  for opt in plan.recovery_options
              ],
          }

          print(json.dumps(result, indent=2))

          # Set outputs for next step
          import subprocess
          subprocess.run([
              "gh", "workflow", "set-output",
              f"root_cause={analysis.root_cause.value}"
          ], env={**os.environ, "GH_TOKEN": os.getenv("GITHUB_TOKEN")})

          print(f"[OK] Diagnosis complete: {analysis.root_cause.value} "
                f"(confidence: {analysis.confidence:.0%})")
          EOF
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}

  generate-recovery-plan:
    name: Generate Recovery Plan
    needs: diagnose-failure
    runs-on: self-hosted
    outputs:
      plan_json: ${{ steps.plan.outputs.plan }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt
          pip install -e .

      - name: Create recovery plan
        id: plan
        run: |
          python3 << 'EOF'
          import json
          import sys
          import os
          from datetime import datetime

          sys.path.insert(0, os.getcwd())

          from core.failure_analyzer import FailureAnalyzer, DiagnosticContext, RootCauseCategory
          from core.recovery_planner import RecoveryPlanner, FailureAnalysis

          # Reconstruct analysis from previous step
          root_cause_str = "${{ needs.diagnose-failure.outputs.root_cause }}"
          confidence = float("${{ needs.diagnose-failure.outputs.confidence }}" or "0.0")

          # Create minimal FailureAnalysis for recovery planning
          analysis = FailureAnalysis(
              timestamp=datetime.now(),
              failed_plugin="${{ inputs.failed_job }}",
              error_message="${{ inputs.failure_message }}",
              root_cause=RootCauseCategory[root_cause_str.upper()],
              root_cause_description="See diagnosis logs",
              confidence=confidence,
          )

          planner = RecoveryPlanner(
              github_token=os.getenv("GITHUB_TOKEN"),
              github_repo=os.getenv("GITHUB_REPOSITORY"),
          )
          plan = planner.plan_recovery(analysis)

          # Output plan as markdown for GitHub issue
          print("[INFO] Recovery plan:")
          print(plan.to_markdown())

          print(f"[OK] {len(plan.recovery_options)} recovery options generated")
          EOF
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}

  decide-recovery-action:
    name: Decide Recovery Action
    needs: [diagnose-failure, generate-recovery-plan]
    runs-on: self-hosted

    steps:
      - name: Evaluate recovery feasibility
        run: |
          echo "Root Cause: ${{ needs.diagnose-failure.outputs.root_cause }}"
          echo "Confidence: ${{ needs.diagnose-failure.outputs.confidence }}"
          echo "Recommended Action: ${{ needs.diagnose-failure.outputs.recovery_option }}"

          # Determine if we should auto-recover or escalate
          CONFIDENCE=$(echo "${{ needs.diagnose-failure.outputs.confidence }}" | sed 's/%//')
          ENABLE_RECOVERY="${{ inputs.enable_auto_recovery }}"

          if [ "$CONFIDENCE" -gt 85 ] && [ "$ENABLE_RECOVERY" = "true" ]; then
            echo "Auto-recovery enabled: confidence is $CONFIDENCE%"
            echo "action=auto-recover" >> $GITHUB_OUTPUT
          else
            echo "Escalating to manual review"
            echo "action=escalate" >> $GITHUB_OUTPUT
          fi

      - name: Create issue for manual review
        if: failure() || steps.evaluate.outputs.action == 'escalate'
        uses: actions/github-script@v8
        with:
          script: |
            const title = `[Failure Recovery] ${{ inputs.failed_job }} - ${{ needs.diagnose-failure.outputs.root_cause }}`;

            const body = `## Failure Diagnosis Report

            **Job**: ${{ inputs.failed_job }}
            **Root Cause**: ${{ needs.diagnose-failure.outputs.root_cause }}
            **Confidence**: ${{ needs.diagnose-failure.outputs.confidence }}

            **Error Message**:
            \`\`\`
            ${{ inputs.failure_message }}
            \`\`\`

            ### Recovery Options

            1. **Automatic Retry** (Low Risk)
               - Re-execute with checkpoint recovery
               - Recommended if infrastructure is stable

            2. **Manual Fix** (Medium Risk)
               - Execute diagnostic commands
               - Verify system state manually

            3. **Escalate** (Low Risk)
               - Skip this run and continue
               - Investigate in next scheduled run

            See detailed recovery plan in Actions logs.

            ### Next Steps

            - Review diagnostic data in workflow run
            - Execute suggested recovery commands
            - Comment with recovery action taken
            - Close issue when resolved
            `;

            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['failure-diagnosis', 'needs-triage'],
            });

  report-status:
    name: Report Status
    needs: [diagnose-failure, decide-recovery-action]
    runs-on: self-hosted
    if: always()

    steps:
      - name: Summary
        run: |
          echo "=========================================="
          echo "Failure Diagnosis Summary"
          echo "=========================================="
          echo "Failed Job: ${{ inputs.failed_job }}"
          echo "Root Cause: ${{ needs.diagnose-failure.outputs.root_cause }}"
          echo "Confidence: ${{ needs.diagnose-failure.outputs.confidence }}"
          echo "Recommended Action: ${{ needs.diagnose-failure.outputs.recovery_option }}"
          echo "=========================================="
          echo ""
          echo "Full diagnostic data available in GitHub Actions logs"
